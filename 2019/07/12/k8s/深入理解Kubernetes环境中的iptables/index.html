<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>深入理解Kubernetes环境中的iptables | 我的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、iptables简介 当主机收到一个数据包后，数据包先在内核空间中处理，若发现目的地址是自身， 则传到用户空间中交给对应的应用程序处理，若发现目的不是自身，则会将包丢弃或进行转发。  iptables实现防火墙功能的原理是：在数据包经过内核的过程中有五处关键地方， 分别是PREROUTING、INPUT、OUTPUT、FORWARD、POSTROUTING，称为钩子函数。 iptables这款">
<meta name="keywords" content="k8s">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Kubernetes环境中的iptables">
<meta property="og:url" content="/2019/07/12/k8s/深入理解Kubernetes环境中的iptables/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="一、iptables简介 当主机收到一个数据包后，数据包先在内核空间中处理，若发现目的地址是自身， 则传到用户空间中交给对应的应用程序处理，若发现目的不是自身，则会将包丢弃或进行转发。  iptables实现防火墙功能的原理是：在数据包经过内核的过程中有五处关键地方， 分别是PREROUTING、INPUT、OUTPUT、FORWARD、POSTROUTING，称为钩子函数。 iptables这款">
<meta property="og:locale" content="default">
<meta property="og:image" content="/2019/07/12/k8s/深入理解Kubernetes环境中的iptables/images/iptable-1.jpeg">
<meta property="og:image" content="/2019/07/12/k8s/深入理解Kubernetes环境中的iptables/images/iptable-2.jpeg">
<meta property="og:image" content="/2019/07/12/k8s/深入理解Kubernetes环境中的iptables/images/iptable-3.jpeg">
<meta property="og:image" content="/2019/07/12/k8s/深入理解Kubernetes环境中的iptables/images/iptable-4.jpeg">
<meta property="og:image" content="/2019/07/12/k8s/深入理解Kubernetes环境中的iptables/images/iptable-5.jpeg">
<meta property="og:image" content="/2019/07/12/k8s/深入理解Kubernetes环境中的iptables/images/iptable-6.jpeg">
<meta property="og:image" content="/2019/07/12/k8s/深入理解Kubernetes环境中的iptables/images/iptable-7.jpeg">
<meta property="og:image" content="/2019/07/12/k8s/深入理解Kubernetes环境中的iptables/images/iptable-8.jpeg">
<meta property="og:image" content="/2019/07/12/k8s/深入理解Kubernetes环境中的iptables/images/iptable-9.jpeg">
<meta property="og:image" content="/2019/07/12/k8s/深入理解Kubernetes环境中的iptables/images/iptable-9.jpeg">
<meta property="og:updated_time" content="2020-05-21T02:35:51.852Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Kubernetes环境中的iptables">
<meta name="twitter:description" content="一、iptables简介 当主机收到一个数据包后，数据包先在内核空间中处理，若发现目的地址是自身， 则传到用户空间中交给对应的应用程序处理，若发现目的不是自身，则会将包丢弃或进行转发。  iptables实现防火墙功能的原理是：在数据包经过内核的过程中有五处关键地方， 分别是PREROUTING、INPUT、OUTPUT、FORWARD、POSTROUTING，称为钩子函数。 iptables这款">
<meta name="twitter:image" content="/2019/07/12/k8s/深入理解Kubernetes环境中的iptables/images/iptable-1.jpeg">
  
  
<!--    <link rel="icon" href="/favicon.ico">-->
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value=""></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">我的博客</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-k8s/深入理解Kubernetes环境中的iptables" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/12/k8s/深入理解Kubernetes环境中的iptables/" class="article-date">
  <time datetime="2019-07-12T04:28:35.000Z" itemprop="datePublished">2019-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      深入理解Kubernetes环境中的iptables
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>一、iptables简介</p>
<pre><code>当主机收到一个数据包后，数据包先在内核空间中处理，若发现目的地址是自身，
则传到用户空间中交给对应的应用程序处理，若发现目的不是自身，则会将包丢弃或进行转发。

iptables实现防火墙功能的原理是：在数据包经过内核的过程中有五处关键地方，
分别是PREROUTING、INPUT、OUTPUT、FORWARD、POSTROUTING，称为钩子函数。
iptables这款用户空间的软件可以在这5处地方写规则，对经过的数据包进行处理，
规则一般的定义为“如果数据包头符合这样的条件，就这样处理数据包”。</code></pre><p><img src="./images/iptable-1.jpeg" alt></p>
<pre><code>iptables中定义有5条链，说白了就是上面说的5个钩子函数，因为每个钩子函数中可以定义多条规则，
每当数据包到达一个钩子函数时，iptables就会从钩子函数中第一条规则开始检查，
看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理该数据包；
否则iptables将继续检查下一条规则，如果该数据包不符合钩子函数中任一条规则，
iptables就会根据该函数预先定义的默认策略来处理数据包。


数据包先经过PREOUTING，由该链确定数据包的走向：

1、目的地址是本地，则发送到INPUT，让INPUT决定是否接收下来送到用户空间，流程为①---&gt;②;

2、若满足PREROUTING的nat表上的转发规则，则发送给FORWARD，然后再经过POSTROUTING发送出去，
流程为： ①---&gt;③---&gt;④---&gt;⑥

主机发送数据包时，流程则是⑤---&gt;⑥

简单点说：
iptables 是用户态的命令行工具，可以操作内核态的 iptables 的几个模块(基于更底层的 netfilter 模块)，
然后达到过滤或网络地址转换数据包。</code></pre><p>二、四表五链</p>
<pre><code>总体说来，iptables就是由“四表五链”组成。
其中表是按照对数据包的操作区分的，链是按照不同的Hook点来区分的，表和链实际上是netfilter的两个维度。

1. 四表

filter：过滤，防火墙。
nat ： 网络地址转换（端口映射，地址映射等）。
mangle：拆解报文，作出修改，封装报文（即对数据包进行修改）。
raw： 关闭nat表上启用的链接追踪机制，为了提高效率使用的，raw本身的含义是指“原生的”、“未经过加工的”，符合raw表所对应规则的数据包将会跳过一些检查，这样就可以提高效率。
优先级为 ： raw &gt; mangle &gt; nat &gt; filter


2. 五链

在设计iptables的时候，在内核空间中选择了5个位置，放置了钩子函数，被称为链chain。前面已经介绍过了。

PREROUTING : 数据包进入路由之前
INPUT : 目的地址为本机
FORWARD : 实现转发
OUTPUT : 原地址为本机，向外发送
POSTROUTING : 发送到网卡之前
对于filter来讲一般只能做在3个链上：INPUT ，FORWARD ，OUTPUT

对于nat来讲一般也只能做在3个链上：PREROUTING ，OUTPUT ，POSTROUTING
而mangle则是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</code></pre><p><img src="./images/iptable-2.jpeg" alt></p>
<p>三、iptables命令</p>
<pre><code>命令格式：iptables [-t 表名] 命令选项 ［链名］ ［条件匹配］ ［-j 目标动作或跳转］

表名、链名用于指定 iptables命令所操作的表和链；
命令选项用于指定管理iptables规则的方式，比如：插入、增加、删除、查看等；
条件匹配用于指定对符合什么样条件的数据包进行处理；
目标动作或跳转用于指定数据包的处理方式，比如允许通过、拒绝、丢弃、跳转（Jump）给其它链处理。


iptables命令选项：

-A 在指定链的末尾添加（append）一条新的规则
-D 删除（delete）指定链中的某一条规则，可以按规则序号和内容删除
-I 在指定链中插入（insert）一条新的规则，默认在第一行添加
-R 修改、替换（replace）指定链中的某一条规则，可以按规则序号和内容替换
-L 列出（list）指定链中所有的规则进行查看
-E 重命名用户定义的链，不改变链本身
-F 清空（flush）
-N 新建（new-chain）一条用户自己定义的规则链
-X 删除指定表中用户自定义的规则链（delete-chain）
-P 设置指定链的默认策略（policy）
-Z 将所有表的所有链的字节和数据包计数器清零
-n 使用数字形式（numeric）显示输出结果
-v 查看规则表详细信息（verbose）的信息
-V 查看版本(version)-h 获取帮助（help）

目标动作或跳转：</code></pre><p><img src="./images/iptable-3.jpeg" alt></p>
<pre><code>下面对2条在Kubernetes集群中用到的iptables命令进行简要解释：

iptables -L -n

列出（list）指定链中所有的规则进行查看，使用数字形式（numeric）显示输出结果。

iptables -P FORWARD ACCEPT

设置指定链（FORWARD）的默认策略为ACCEPT，也就是允许数据包通过。</code></pre><p>四、Kubernetes环境中的iptables</p>
<pre><code>Node节点的iptables是由kube-proxy生成的。

Kubernetes中的 kube-proxy 模块会调用 iptables go client 向linux 内核中去用户自定义 iptables chain，
和往一些表内(如 filter 表或 nat 表)写自定义rule，来实现每一个 Node 节点做到四层负载均衡功能，且由于 kube-proxy作为 DaemonSet 部署，会在每一个 Node 节点内运行这个进程，这样，这种负载均衡还是分布式的。
另外，由于集群内每次新建一个 service 都会在每一个 Node 节点上写 iptables rules，
由于 iptables 的数据结构是链表，所以每一次读操作都是 O(n)，效率就很低了，
导致一个 k8s cluster如果使用 iptables 作为负载均衡底层技术的话，就只能支撑中小数量的 service 了。
这一点就没有 ipvs 效率高，ipvs 的数据结构是哈希表，
而且 ipvs 天生就是为负载均衡而生，支持的负载均衡策略更多，包括 rr、wrr 或 lc 等等。



我们看一下Kubernetes Service，它是一个虚拟IP，并伴随着一组Pod IP作为Endpoint（通过标签选择器识别）。
它们充当虚拟负载均衡器，其IP保持不变，而后端Pod IP可能会不断变化。    </code></pre><p><img src="./images/iptable-4.jpeg" alt></p>
<pre><code>Service的Cluster IP和Port，如下图所示：</code></pre><p><img src="./images/iptable-5.jpeg" alt>    </p>
<pre><code>整个虚拟IP实际上是一组iptables（最新版本可以选择使用IPVS）规则，由Kubernetes组件kube-proxy管理。

有了这些iptables规则，每当数据包发往Service IP时，
它就进行DNAT（Destination Network Address Translation，目标网络地址转换，
是一种改变数据包目的ip地址的技术）操作，ip
这意味着目标IP从Service IP更改为其中一个Endpoint - Pod IP - 由iptables随机选择。
这可确保负载均匀分布在后端Pod中。</code></pre><p><img src="./images/iptable-6.jpeg" alt></p>
<pre><code>kube-proxy对iptables的链进行了扩充，
自定义了KUBE-SERVICES，KUBE-NODEPORTS，KUBE-POSTROUTING，KUBE-MARK-MASQ和KUBE-MARK-DROP五个链，
并主要通过为KUBE-SERVICES chain增加rule来配制traffic routing 规则。

执行命令，查看iptables规则：
iptables -t nat -nvL

输出信息比较多，我们只看看与nginx svc Cluster IP（10.10.248.36）相关的信息，如图所示：</code></pre><p><img src="./images/iptable-7.jpeg" alt></p>
<pre><code>这两条规则的含义是：
（1）如果Cluster内的Pod（源地址来自10.122.0.0/16），要访问nginx svc，则允许。
（2）其他源地址访问nginx svc，则跳转到规则KUBE-SVC-4N57TFCL4MD7ZTDA。

KUBE-SVC-4N57TFCL4MD7ZTDA规则如下图所示：    </code></pre><p><img src="./images/iptable-8.jpeg" alt></p>
<pre><code>因为，我们只部署了一个Pod，所有流量都跳转到规则 KUBE-SEP-H5CCP4V3TZFUD6ZZ。

在看一下KUBE-SEP-H5CCP4V3TZFUD6ZZ规则：

iptables-save | grep KUBE-SEP-H5CCP4V3TZFUD6ZZ</code></pre><p><img src="./images/iptable-9.jpeg" alt></p>
<pre><code>-A KUBE-SEP-H5CCP4V3TZFUD6ZZ -p tcp -m comment --comment &quot;default/nginx:&quot; -m tcp -j DNAT --to-destination 10.122.14.72:80</code></pre><p><img src="./images/iptable-9.jpeg" alt></p>
<pre><code>即将请求分别转发到后端的Pod。
如果有多个Pod，iptables将访问Service的流量转发到后端的多个Pod， 而且使用类似轮询的负载均衡策略。
另外， 需要补充一点： Cluster的每一个节点都配置了相同的iptables规则，这样就确保了整个Cluster都能够通过Service的Cluster IP访问Service。</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="/2019/07/12/k8s/深入理解Kubernetes环境中的iptables/" data-id="cklw4t033000oy49bz6xm4925" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/k8s/">k8s</a></li></ul>

    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2019/07/12/java/java多线程竞拍/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          阿里云面试题-多线程竞拍
        
      </div>
    </a>
  
  
    <a href="/2019/07/11/zookeeper/zookeeper_expiryQueue/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">zookeeper之ExpiryQueue</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    <!--


-->

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/05/kafka/kafka命令/">kafka生产消费命令</a>
          </li>
        
          <li>
            <a href="/2021/03/05/es/es-template/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/05/es/es-template/">elasticsearch索引模版</a>
          </li>
        
          <li>
            <a href="/2021/03/05/es/elk/">日志收集</a>
          </li>
        
          <li>
            <a href="/2021/03/05/es/dsl/">elasticsearch dsl</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2021 hezhengkui&nbsp;&nbsp;
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;hzkvectory@163.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>
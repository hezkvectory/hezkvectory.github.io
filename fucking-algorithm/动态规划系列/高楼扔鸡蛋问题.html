<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>我的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="经典动态规划问题：高楼扔鸡蛋        相关推荐：  如何判断回文链表 SQL进阶技巧  读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目： 887.鸡蛋掉落 ———– 今天要聊一个很经典的算法问题，若干层楼，若干个鸡蛋，让你算出最少的尝试次数，找到鸡蛋恰好摔不碎的那层楼。国内大厂以及谷歌脸书面试都经常考察这道题，只不过他们觉得扔鸡蛋太浪费，改成扔杯子，扔破碗什么">
<meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="/fucking-algorithm/动态规划系列/高楼扔鸡蛋问题.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="经典动态规划问题：高楼扔鸡蛋        相关推荐：  如何判断回文链表 SQL进阶技巧  读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目： 887.鸡蛋掉落 ———– 今天要聊一个很经典的算法问题，若干层楼，若干个鸡蛋，让你算出最少的尝试次数，找到鸡蛋恰好摔不碎的那层楼。国内大厂以及谷歌脸书面试都经常考察这道题，只不过他们觉得扔鸡蛋太浪费，改成扔杯子，扔破碗什么">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://img.shields.io/github/stars/labuladong/fucking-algorithm?label=Stars&style=flat-square&logo=GitHub">
<meta property="og:image" content="https://img.shields.io/badge/%E7%9F%A5%E4%B9%8E-@labuladong-000000.svg?style=flat-square&logo=Zhihu">
<meta property="og:image" content="https://img.shields.io/badge/公众号-@labuladong-000000.svg?style=flat-square&logo=WeChat">
<meta property="og:image" content="https://img.shields.io/badge/B站-@labuladong-000000.svg?style=flat-square&logo=Bilibili">
<meta property="og:image" content="/fucking-algorithm/动态规划系列/高楼扔鸡蛋问题.htm/pictures/souyisou.png">
<meta property="og:image" content="/fucking-algorithm/动态规划系列/高楼扔鸡蛋问题.htm/pictures/%E6%89%94%E9%B8%A1%E8%9B%8B/1.jpg">
<meta property="og:image" content="/fucking-algorithm/动态规划系列/高楼扔鸡蛋问题.htm/pictures/%E6%89%94%E9%B8%A1%E8%9B%8B/formula1.png">
<meta property="og:image" content="/fucking-algorithm/动态规划系列/高楼扔鸡蛋问题.htm/pictures/%E6%89%94%E9%B8%A1%E8%9B%8B/2.jpg">
<meta property="og:image" content="/fucking-algorithm/动态规划系列/高楼扔鸡蛋问题.htm/pictures/qrcode.jpg">
<meta property="og:updated_time" content="2021-03-02T03:51:52.858Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我的博客">
<meta name="twitter:description" content="经典动态规划问题：高楼扔鸡蛋        相关推荐：  如何判断回文链表 SQL进阶技巧  读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目： 887.鸡蛋掉落 ———– 今天要聊一个很经典的算法问题，若干层楼，若干个鸡蛋，让你算出最少的尝试次数，找到鸡蛋恰好摔不碎的那层楼。国内大厂以及谷歌脸书面试都经常考察这道题，只不过他们觉得扔鸡蛋太浪费，改成扔杯子，扔破碗什么">
<meta name="twitter:image" content="https://img.shields.io/github/stars/labuladong/fucking-algorithm?label=Stars&style=flat-square&logo=GitHub">
  
  
<!--    <link rel="icon" href="/favicon.ico">-->
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value=""></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">我的博客</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="page-" class="article article-type-page" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/fucking-algorithm/动态规划系列/高楼扔鸡蛋问题.html" class="article-date">
  <time datetime="2021-03-02T03:51:52.858Z" itemprop="datePublished">2021-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="经典动态规划问题：高楼扔鸡蛋"><a href="#经典动态规划问题：高楼扔鸡蛋" class="headerlink" title="经典动态规划问题：高楼扔鸡蛋"></a>经典动态规划问题：高楼扔鸡蛋</h1><p align="center">
<a href="https://github.com/labuladong/fucking-algorithm" target="view_window"><img alt="GitHub" src="https://img.shields.io/github/stars/labuladong/fucking-algorithm?label=Stars&style=flat-square&logo=GitHub"></a>
<a href="https://www.zhihu.com/people/labuladong" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/%E7%9F%A5%E4%B9%8E-@labuladong-000000.svg?style=flat-square&logo=Zhihu"></a>
<a href="https://i.loli.net/2020/10/10/MhRTyUKfXZOlQYN.jpg" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/公众号-@labuladong-000000.svg?style=flat-square&logo=WeChat"></a>
<a href="https://space.bilibili.com/14089380" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/B站-@labuladong-000000.svg?style=flat-square&logo=Bilibili"></a>
</p>

<p><img src="/fucking-algorithm/动态规划系列/高楼扔鸡蛋问题.htm/pictures/souyisou.png" alt></p>
<p>相关推荐：</p>
<ul>
<li><a href="https://labuladong.gitbook.io/algo" target="_blank" rel="noopener">如何判断回文链表</a></li>
<li><a href="https://labuladong.gitbook.io/algo" target="_blank" rel="noopener">SQL进阶技巧</a></li>
</ul>
<p>读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：</p>
<p><a href="https://leetcode-cn.com/problems/super-egg-drop/" target="_blank" rel="noopener">887.鸡蛋掉落</a></p>
<p><strong>———–</strong></p>
<p>今天要聊一个很经典的算法问题，若干层楼，若干个鸡蛋，让你算出最少的尝试次数，找到鸡蛋恰好摔不碎的那层楼。国内大厂以及谷歌脸书面试都经常考察这道题，只不过他们觉得扔鸡蛋太浪费，改成扔杯子，扔破碗什么的。</p>
<p>具体的问题等会再说，但是这道题的解法技巧很多，光动态规划就好几种效率不同的思路，最后还有一种极其高效数学解法。秉承咱们号一贯的作风，拒绝奇技淫巧，拒绝过于诡异的技巧，因为这些技巧无法举一反三，学了也不划算。</p>
<p>下面就来用我们一直强调的动态规划通用思路来研究一下这道题。</p>
<h3 id="一、解析题目"><a href="#一、解析题目" class="headerlink" title="一、解析题目"></a>一、解析题目</h3><p>题目是这样：你面前有一栋从 1 到 <code>N</code> 共 <code>N</code> 层的楼，然后给你 <code>K</code> 个鸡蛋（<code>K</code> 至少为 1）。现在确定这栋楼存在楼层 <code>0 &lt;= F &lt;= N</code>，在这层楼将鸡蛋扔下去，鸡蛋<strong>恰好没摔碎</strong>（高于 <code>F</code> 的楼层都会碎，低于 <code>F</code> 的楼层都不会碎）。现在问你，<strong>最坏</strong>情况下，你<strong>至少</strong>要扔几次鸡蛋，才能<strong>确定</strong>这个楼层 <code>F</code> 呢？</p>
<p>也就是让你找摔不碎鸡蛋的最高楼层 <code>F</code>，但什么叫「最坏情况」下「至少」要扔几次呢？我们分别举个例子就明白了。</p>
<p>比方说<strong>现在先不管鸡蛋个数的限制</strong>，有 7 层楼，你怎么去找鸡蛋恰好摔碎的那层楼？</p>
<p>最原始的方式就是线性扫描：我先在 1 楼扔一下，没碎，我再去 2 楼扔一下，没碎，我再去 3 楼……</p>
<p>以这种策略，<strong>最坏</strong>情况应该就是我试到第 7 层鸡蛋也没碎（<code>F = 7</code>），也就是我扔了 7 次鸡蛋。</p>
<p>先在你应该理解什么叫做「最坏情况」下了，<strong>鸡蛋破碎一定发生在搜索区间穷尽时</strong>，不会说你在第 1 层摔一下鸡蛋就碎了，这是你运气好，不是最坏情况。</p>
<p>现在再来理解一下什么叫「至少」要扔几次。依然不考虑鸡蛋个数限制，同样是 7 层楼，我们可以优化策略。</p>
<p>最好的策略是使用二分查找思路，我先去第 <code>(1 + 7) / 2 = 4</code> 层扔一下：</p>
<p>如果碎了说明 <code>F</code> 小于 4，我就去第 <code>(1 + 3) / 2 = 2</code> 层试……</p>
<p>如果没碎说明 <code>F</code> 大于等于 4，我就去第 <code>(5 + 7) / 2 = 6</code> 层试……</p>
<p>以这种策略，<strong>最坏</strong>情况应该是试到第 7 层鸡蛋还没碎（<code>F = 7</code>），或者鸡蛋一直碎到第 1 层（<code>F = 0</code>）。然而无论那种最坏情况，只需要试 <code>log7</code> 向上取整等于 3 次，比刚才尝试 7 次要少，这就是所谓的<strong>至少</strong>要扔几次。</p>
<p>PS：这有点像 Big O 表示法计算​算法的复杂度。</p>
<p>实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，<strong>现在给你了鸡蛋个数的限制 <code>K</code>，直接使用二分思路就不行了</strong>。</p>
<p>比如说只给你 1 个鸡蛋，7 层楼，你敢用二分吗？你直接去第 4 层扔一下，如果鸡蛋没碎还好，但如果碎了你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层 <code>F</code> 了。这种情况下只能用线性扫描的方法，算法返回结果应该是 7。</p>
<p>有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？</p>
<p>很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。</p>
<p>如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次​。</p>
<p>最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。</p>
<p>说了这么多废话，就是确保大家理解了题目的意思，而且认识到这个题目确实复杂，就连我们手算都不容易，如何用算法解决呢？</p>
<h3 id="二、思路分析"><a href="#二、思路分析" class="headerlink" title="二、思路分析"></a>二、思路分析</h3><p>对动态规划问题，直接套我们以前多次强调的框架即可：这个问题有什么「状态」，有什么「选择」，然后穷举。</p>
<p><strong>「状态」很明显，就是当前拥有的鸡蛋数 <code>K</code> 和需要测试的楼层数 <code>N</code></strong>。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。</p>
<p><strong>「选择」其实就是去选择哪层楼扔鸡蛋</strong>。回顾刚才的线性扫描和二分思路，二分查找每次选择到楼层区间的中间去扔鸡蛋，而线性扫描选择一层层向上测试。不同的选择会造成状态的转移。</p>
<p>现在明确了「状态」和「选择」，<strong>动态规划的基本思路就形成了</strong>：肯定是个二维的 <code>dp</code> 数组或者带有两个状态参数的 <code>dp</code> 函数来表示状态转移；外加一个 for 循环来遍历所有选择，择最优的选择更新状态：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前状态为 K 个鸡蛋，面对 N 层楼</span></span><br><span class="line"><span class="comment"># 返回这个状态下的最优结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(K, N)</span>:</span></span><br><span class="line">    int res</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        res = min(res, 这次在第 i 层楼扔鸡蛋)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>这段伪码还没有展示递归和状态转移，不过大致的算法框架已经完成了。</p>
<p>我们选择在第 <code>i</code> 层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。<strong>注意，这时候状态转移就来了</strong>：</p>
<p><strong>如果鸡蛋碎了</strong>，那么鸡蛋的个数 <code>K</code> 应该减一，搜索的楼层区间应该从 <code>[1..N]</code> 变为 <code>[1..i-1]</code> 共 <code>i-1</code> 层楼；</p>
<p><strong>如果鸡蛋没碎</strong>，那么鸡蛋的个数 <code>K</code> 不变，搜索的楼层区间应该从  <code>[1..N]</code> 变为 <code>[i+1..N]</code> 共 <code>N-i</code> 层楼。</p>
<p><img src="/fucking-algorithm/动态规划系列/高楼扔鸡蛋问题.htm/pictures/%E6%89%94%E9%B8%A1%E8%9B%8B/1.jpg" alt></p>
<p>PS：细心的读者可能会问，在第i层楼扔鸡蛋如果没碎，楼层的搜索区间缩小至上面的楼层，是不是应该包含第i层楼呀？不必，因为已经包含了。开头说了 F 是可以等于 0 的，向上递归后，第i层楼其实就相当于第 0 层，可以被取到，所以说并没有错误。</p>
<p>因为我们要求的是<strong>最坏情况</strong>下扔鸡蛋的次数，所以鸡蛋在第 <code>i</code> 层楼碎没碎，取决于那种情况的结果<strong>更大</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(K, N)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        <span class="comment"># 最坏情况下的最少扔鸡蛋次数</span></span><br><span class="line">        res = min(res, </span><br><span class="line">                  max( </span><br><span class="line">                        dp(K - <span class="number">1</span>, i - <span class="number">1</span>), <span class="comment"># 碎</span></span><br><span class="line">                        dp(K, N - i)      <span class="comment"># 没碎</span></span><br><span class="line">                     ) + <span class="number">1</span> <span class="comment"># 在第 i 楼扔了一次</span></span><br><span class="line">                 )</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>递归的 base case 很容易理解：当楼层数 <code>N</code> 等于 0 时，显然不需要扔鸡蛋；当鸡蛋数 <code>K</code> 为 1 时，显然只能线性扫描所有楼层：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(K, N)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> K == <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">    <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>至此，其实这道题就解决了！只要添加一个备忘录消除重叠子问题即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(K: int, N: int)</span>:</span></span><br><span class="line"></span><br><span class="line">    memo = dict()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(K, N)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> K == <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> (K, N) <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(K, N)]</span><br><span class="line"></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="comment"># 穷举所有可能的选择</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">            res = min(res, </span><br><span class="line">                      max(</span><br><span class="line">                            dp(K, N - i), </span><br><span class="line">                            dp(K - <span class="number">1</span>, i - <span class="number">1</span>)</span><br><span class="line">                         ) + <span class="number">1</span></span><br><span class="line">                  )</span><br><span class="line">        <span class="comment"># 记入备忘录</span></span><br><span class="line">        memo[(K, N)] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp(K, N)</span><br></pre></td></tr></table></figure>

<p>这个算法的时间复杂度是多少呢？<strong>动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度</strong>。</p>
<p>函数本身的复杂度就是忽略递归部分的复杂度，这里 <code>dp</code> 函数中有一个 for 循环，所以函数本身的复杂度是 O(N)。</p>
<p>子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。</p>
<p>所以算法的总时间复杂度是 O(K*N^2), 空间复杂度 O(KN)。</p>
<h3 id="三、疑难解答"><a href="#三、疑难解答" class="headerlink" title="三、疑难解答"></a>三、疑难解答</h3><p>这个问题很复杂，但是算法代码却十分简洁，这就是动态规划的特性，穷举加备忘录/DP table 优化，真的没啥新意。</p>
<p>首先，有读者可能不理解代码中为什么用一个 for 循环遍历楼层 <code>[1..N]</code>，也许会把这个逻辑和之前探讨的线性扫描混为一谈。其实不是的，<strong>这只是在做一次「选择」</strong>。</p>
<p>比方说你有 2 个鸡蛋，面对 10 层楼，你<strong>这次</strong>选择去哪一层楼扔呢？不知道，那就把这 10 层楼全试一遍。至于下次怎么选择不用你操心，有正确的状态转移，递归会算出每个选择的代价，我们取最优的那个就是最优解。</p>
<p>另外，这个问题还有更好的解法，比如修改代码中的 for 循环为二分搜索，可以将时间复杂度降为 O(K*N*logN)；再改进动态规划解法可以进一步降为 O(KN)；使用数学方法解决，时间复杂度达到最优 O(K*logN)，空间复杂度达到 O(1)。</p>
<p>二分的解法也有点误导性，你很可能以为它跟我们之前讨论的二分思路扔鸡蛋有关系，实际上没有半毛钱关系。能用二分搜索是因为状态转移方程的函数图像具有单调性，可以快速找到最值。</p>
<p>简单介绍一下二分查找的优化吧，其实只是在优化这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(K, N)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= N:</span><br><span class="line">        <span class="comment"># 最坏情况下的最少扔鸡蛋次数</span></span><br><span class="line">        res = min(res, </span><br><span class="line">                  max( </span><br><span class="line">                        dp(K - <span class="number">1</span>, i - <span class="number">1</span>), <span class="comment"># 碎</span></span><br><span class="line">                        dp(K, N - i)      <span class="comment"># 没碎</span></span><br><span class="line">                     ) + <span class="number">1</span> <span class="comment"># 在第 i 楼扔了一次</span></span><br><span class="line">                 )</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>这个 for 循环就是下面这个状态转移方程的具体代码实现：</p>
<!-- $$ dp(K, N) = \min_{0 <= i <= N}\{\max\{dp(K - 1, i - 1), dp(K, N - i)\} + 1\}$$ -->

<p><img src="/fucking-algorithm/动态规划系列/高楼扔鸡蛋问题.htm/pic/../pictures/%E6%89%94%E9%B8%A1%E8%9B%8B/formula1.png" alt></p>
<p>首先我们根据 <code>dp(K, N)</code> 数组的定义（有 <code>K</code> 个鸡蛋面对 <code>N</code> 层楼，最少需要扔几次），<strong>很容易知道 <code>K</code> 固定时，这个函数一定是单调递增的</strong>，无论你策略多聪明，楼层增加测试次数一定要增加。</p>
<p>那么注意 <code>dp(K - 1, i - 1)</code> 和 <code>dp(K, N - i)</code> 这两个函数，其中 <code>i</code> 是从 1 到 <code>N</code> 单增的，如果我们固定 <code>K</code> 和 <code>N</code>，<strong>把这两个函数看做关于 <code>i</code> 的函数，前者随着 <code>i</code> 的增加应该也是单调递增的，而后者随着 <code>i</code> 的增加应该是单调递减的</strong>：</p>
<p><img src="/fucking-algorithm/动态规划系列/高楼扔鸡蛋问题.htm/pictures/%E6%89%94%E9%B8%A1%E8%9B%8B/2.jpg" alt></p>
<p>这时候求二者的较大值，再求这些最大值之中的最小值，其实就是求这个交点嘛，熟悉二分搜索的同学肯定敏感地想到了，这不就是相当于求 Valley（山谷）值嘛，可以用二分查找来快速寻找这个点的。</p>
<p>直接贴一下代码吧，思路还是完全一样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">    memo = dict()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(K, N)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> K == <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (K, N) <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(K, N)]</span><br><span class="line">                            </span><br><span class="line">        <span class="comment"># for 1 &lt;= i &lt;= N:</span></span><br><span class="line">        <span class="comment">#     res = min(res, </span></span><br><span class="line">        <span class="comment">#             max( </span></span><br><span class="line">    <span class="comment">#                     dp(K - 1, i - 1), </span></span><br><span class="line">    <span class="comment">#                     dp(K, N - i)      </span></span><br><span class="line">        <span class="comment">#                 ) + 1 </span></span><br><span class="line">        <span class="comment">#             )</span></span><br><span class="line"></span><br><span class="line">        res = float(<span class="string">'INF'</span>)</span><br><span class="line">        <span class="comment"># 用二分搜索代替线性搜索</span></span><br><span class="line">        lo, hi = <span class="number">1</span>, N</span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            broken = dp(K - <span class="number">1</span>, mid - <span class="number">1</span>) <span class="comment"># 碎</span></span><br><span class="line">            not_broken = dp(K, N - mid) <span class="comment"># 没碎</span></span><br><span class="line">            <span class="comment"># res = min(max(碎，没碎) + 1)</span></span><br><span class="line">            <span class="keyword">if</span> broken &gt; not_broken:</span><br><span class="line">                hi = mid - <span class="number">1</span></span><br><span class="line">                res = min(res, broken + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">                res = min(res, not_broken + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        memo[(K, N)] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp(K, N)</span><br></pre></td></tr></table></figure>

<p>这里就不展开其他解法了，留在下一篇文章 <a href="https://labuladong.gitbook.io/algo" target="_blank" rel="noopener">高楼扔鸡蛋进阶</a></p>
<p>我觉得吧，我们这种解法就够了：找状态，做选择，足够清晰易懂，可流程化，可举一反三。掌握这套框架学有余力的话，再去考虑那些奇技淫巧也不迟。</p>
<p>最后预告一下，《动态规划详解（修订版）》和《回溯算法详解（修订版）》已经动笔了，教大家用模板的力量来对抗变化无穷的算法题，敬请期待。</p>
<p><strong>＿＿＿＿＿＿＿＿＿＿＿＿＿</strong></p>
<p><strong>刷算法，学套路，认准 labuladong，公众号和 <a href="https://labuladong.gitbook.io/algo" target="_blank" rel="noopener">在线电子书</a> 持续更新最新文章</strong>。</p>
<p><strong>本小抄即将出版，微信扫码关注公众号，后台回复「小抄」限时免费获取，回复「进群」可进刷题群一起刷题，带你搞定 LeetCode</strong>。</p>
<p align="center">
<img src="/fucking-algorithm/动态规划系列/高楼扔鸡蛋问题.htm/pictures/qrcode.jpg" width="200">
</p>

<p>======其他语言代码======</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="/fucking-algorithm/动态规划系列/高楼扔鸡蛋问题.html" data-id="cklrh5za5001vro9bndm5nlpq" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    <!--


-->

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#经典动态规划问题：高楼扔鸡蛋"><span class="toc-number">1.</span> <span class="toc-text">经典动态规划问题：高楼扔鸡蛋</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、解析题目"><span class="toc-number">1.0.1.</span> <span class="toc-text">一、解析题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、思路分析"><span class="toc-number">1.0.2.</span> <span class="toc-text">二、思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、疑难解答"><span class="toc-number">1.0.3.</span> <span class="toc-text">三、疑难解答</span></a></li></ol></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2021 hezhengkui&nbsp;&nbsp;
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;hzkvectory@163.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>